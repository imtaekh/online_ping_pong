<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Ping-Pong Online</title>
  </head>
  <body>
    <script src="/socket.io/socket.io.js"></script>
    <script src="//code.jquery.com/jquery-1.11.1.js"></script>
<script>
$(function(){
  var GAME_SETTINGS = null;
  var INTERVAL = 10;

  var socket = io();
  var canvas = document.createElement('canvas');
  $(canvas).css("display", "block");
  $(canvas).css("border", "black 1px solid");
  $(canvas).css("margin", "0 auto");
  var ctx = canvas.getContext("2d");
  var serverObjects;
  var mainLoop = function(){};
  var interval = setInterval(function(){
    mainLoop();
  },INTERVAL);

  socket.on('connected', function(SERVER_GAME_SETTINGS){
    GAME_SETTINGS = SERVER_GAME_SETTINGS;
    $(canvas).attr("width", GAME_SETTINGS.WIDTH);
    $(canvas).attr("height", GAME_SETTINGS.HEIGHT);
    document.body.appendChild(canvas);
    start.initialize();
  });

  socket.on('in', function(){
    waiting.destroy();
    playing.initialize();
  });

  socket.on('update', function(statuses){
    serverObjects = statuses;
  });

  socket.on('destroy', function(){
    playing.destroy();
    opponentLeft.initialize();
  });

  function drawBackground(globalAlpha,color){
    ctx.save();
    ctx.globalAlpha = globalAlpha?globalAlpha:1;
    ctx.fillStyle = color?color:GAME_SETTINGS.BACKGROUND_COLOR;
    ctx.fillRect(0,0,GAME_SETTINGS.WIDTH,GAME_SETTINGS.HEIGHT);
    ctx.restore();
  }

  function drawBorder(){
    ctx.fillStyle = "#000000";
    ctx.fillRect(0,0,GAME_SETTINGS.WIDTH,GAME_SETTINGS.BORDER_WIDTH);
    ctx.fillRect(0,GAME_SETTINGS.HEIGHT-GAME_SETTINGS.BORDER_WIDTH,GAME_SETTINGS.WIDTH,GAME_SETTINGS.BORDER_WIDTH);
  }

  function drawNet(){
    var num = 10;
    var height = GAME_SETTINGS.HEIGHT/((num+1)*2);
    var y = height/2;
    var x = (GAME_SETTINGS.WIDTH-GAME_SETTINGS.NET.WIDTH)/2;
    ctx.fillStyle = "#000000";
    while(y < GAME_SETTINGS.HEIGHT){
        ctx.fillRect(x,y,GAME_SETTINGS.NET.WIDTH,height);
        y += height*2;
    }
  }

  var start = new (function(){
    var start = this;

    start.button1 = new ButtonObject();
    start.button1.setEvents = function(){
      $(canvas).on("click",this.click);
      $(canvas).on("mousemove",this.mousemove);
    };
    start.button1.click = function(e){
      var rect = start.button1.data.rect;
      if(pointSquareCollusionCheck(e.offsetX, e.offsetY, rect)){
        start.toWaiting();
      }
    };
    start.button1.update = function(){
      var text = this.data.text;
      var animation = this.data.animation;
      animation.count += animation.dir;
      if(animation.count <= 0 || animation.count >= animation.maxCount ){
        animation.dir *= -1;
      }
      text.globalAlpha = 0.2 + 0.7*(animation.count/100);
    };
    start.button1.mousemove = function(e){
      var rect = start.button1.data.rect;
      var text = start.button1.data.text;
      var mouseover = pointSquareCollusionCheck(e.offsetX, e.offsetY, rect);

      rect.color = mouseover?rect.colorData.mouseover  :rect.colorData.default;
      text.color = mouseover?text.colorData.mouseover  :text.colorData.default;
    };

    start.initialize = function(){
      start.button1.initialize(canvas,ctx,GAME_SETTINGS,{
        rect: {
          x: undefined,
          y: undefined,
          width: 230,
          height: 50,
          lineWidth: 2,
          color: {fill:undefined, stroke:undefined},
          colorData: {
            default: {fill:"#1099cc", stroke:"#223344"},
            mouseover: {fill:"#0686e0", stroke:"#223344"}
          }
        },
        text:{
          x: undefined,
          y: undefined,
          size: 30,
          font: "Arial",
          textBaseline: "middle",
          textAlign: "center",
          lineWidth: 2,
          message: "START GAME",
          color: {fill:undefined, stroke:undefined},
          colorData: {
            default: {fill:"#123456", stroke:undefined},
            mouseover: {fill:"#ddeeff", stroke:undefined}
          }
        },
        animation: {
          maxCount: 100,
          count: 0,
          dir: 1,
        }
      });
      mainLoop = start.loop;
    };
    start.loop = function(){
      start.button1.update();
      drawBackground();
      start.button1.draw();
    };
    start.destroy = function(){
      $(canvas).off();
    };
    start.toWaiting = function(){
      start.destroy();
      socket.emit('waiting');
      waiting.initialize();
    };
  })();

  var waiting = new (function(){
    var waiting = this;

    waiting.text1 = new TextObject();
    waiting.text1.update = function(){
      var text = this.data.text;
      var animation = this.data.animation;
      animation.count += animation.dir;
      if(animation.count <= 0 || animation.count >= animation.maxCount ){
        animation.dir *= -1;
      }
      text.globalAlpha = 0.2 + 0.7*(animation.count/100);
    };

    waiting.initialize = function(){
      waiting.text1.initialize(canvas,ctx,GAME_SETTINGS,{
        text:{
          x: undefined,
          y: undefined,
          size: 30,
          font: "Arial",
          textBaseline: "middle",
          textAlign: "center",
          lineWidth: 2,
          message: "WAITING FOR OPPONENT..",
          globalAlpha: undefined,
          color: {fill: undefined, stroke: undefined},
          colorData: {
            default: {fill: "#000000", stroke: undefined}
          }
        },
        animation: {
          maxCount: 100,
          count: 0,
          dir: 1,
        }
      });
      mainLoop = waiting.loop;
    };
    waiting.loop = function(){
      waiting.text1.update();
      drawBackground();
      waiting.text1.draw();
    };
    waiting.destroy = function(){
    }
  })();

  var playing = new (function(){
    var playing = this;
    playing.interval = null;

    playing.initialize = function(){
      $('body').on('keydown', function(e){
        if(e.keyCode>=37 && e.keyCode<=40){
          e.preventDefault();
          socket.emit('keydown', e.keyCode);
        }
      });
      $('body').on('keyup', function(e){
        if(e.keyCode>=37 && e.keyCode<=40){
          e.preventDefault();
          socket.emit('keyup', e.keyCode);
        }
      });
      $('canvas').on('mousemove', function(e){
        e.preventDefault();
        socket.emit('mousemove', e.offsetX, e.offsetY);
      });
      $('canvas').on('click', function(e){
        e.preventDefault();
        socket.emit('click', e.offsetX, e.offsetY);
      });
      mainLoop = playing.loop;
    };
    playing.loop = function(){

      if(!serverObjects) return;
      drawBackground();
      drawNet();
      drawBorder();
      serverObjects.forEach(function(status){
        switch(status.shape){
          case "rectangle":
            drawRect(ctx,status.rect);
            break;
          case "circle":
            ctx.fillStyle = status.color;
            ctx.beginPath();
            ctx.arc(status.x,status.y,status.r,0,2*Math.PI);
            ctx.stroke();
            ctx.fill();
            break;
          case "text":
            drawText(ctx,status.text);
            break;
        }
      });
    };
    playing.destroy = function(){
      $('body').off();
      $('canvas').off();
    };
  })();

  var opponentLeft = new (function(){
    var opponentLeft = this;
    opponentLeft.interval = null;
    opponentLeft.text1 = new TextObject();
    opponentLeft.text1.update = function(){
      var text = this.data.text;
      var animation = this.data.animation;
      animation.count++;
      text.globalAlpha = 0.2 + 0.7*(animation.count/100);
    };
    opponentLeft.text2 = new TextObject();
    opponentLeft.text2.update = function(){
      var text = this.data.text;
      var animation = this.data.animation;
      if(animation.count == 0) text.color = undefined;
      animation.count++;
      if(animation.count == 101){
        text.color = text.colorData.default;
      }
      if(animation.count > 100) text.globalAlpha = ((animation.count-100)/150);
    };

    opponentLeft.initialize = function(){
      opponentLeft.count =0;
      opponentLeft.text1.initialize(canvas,ctx,GAME_SETTINGS,{
        text:{
          x: undefined,
          y: GAME_SETTINGS.HEIGHT/2-20,
          size: 32,
          font: "Arial",
          textBaseline: "middle",
          textAlign: "center",
          lineWidth: 2,
          message: "OPPONENT LEFT!",
          globalAlpha: undefined,
          color: {fill: undefined, stroke: undefined},
          colorData: {default:{fill: "#000000", stroke: undefined}}
        },
        animation: {
          maxCount: 200,
          count: 0,
        }
      });
      opponentLeft.text2.initialize(canvas,ctx,GAME_SETTINGS,{
        text:{
          x: undefined,
          y: GAME_SETTINGS.HEIGHT/2+20,
          size: 25,
          font: "Arial",
          textBaseline: "middle",
          textAlign: "center",
          lineWidth: 2,
          message: "GOING BACK TO START..",
          globalAlpha: undefined,
          color: {fill: undefined, stroke: undefined},
          colorData: {default:{fill: "#000000", stroke: undefined}}
        },
        animation: {
          count: 0,
        }
      });
      mainLoop = opponentLeft.loop;
    };
    opponentLeft.loop = function(){
      opponentLeft.text1.update();
      opponentLeft.text2.update();
      opponentLeft.update();
      opponentLeft.draw();
      opponentLeft.text1.draw();
      opponentLeft.text2.draw();
    };
    opponentLeft.count = undefined;
    opponentLeft.imgData = undefined;
    opponentLeft.update = function(){
      if(opponentLeft.count == 0){
        drawBackground(0.8);
        opponentLeft.imgData=ctx.getImageData(0,0,GAME_SETTINGS.WIDTH,GAME_SETTINGS.HEIGHT);
      }
      opponentLeft.count++
      if(opponentLeft.count >= 300){
        opponentLeft.destroy();
        start.initialize();
      }
    }
    opponentLeft.draw = function(){
      ctx.putImageData(opponentLeft.imgData,0,0);
    }
    opponentLeft.destroy = function(){
    };
  })();
})

// Objects
function TextObject(){}

TextObject.prototype.initialize = function(canvas,ctx,GAME_SETTINGS,data){
  this.canvas = canvas;
  this.ctx = ctx;
  this.GAME_SETTINGS = GAME_SETTINGS;
  this.data = data;
  if(this.setEvents) this.setEvents();

  var text = this.data.text;
  var animation = data.animation;
  text.x = text.x?text.x:GAME_SETTINGS.WIDTH/2;
  text.y = text.y?text.y:GAME_SETTINGS.HEIGHT/2;
  text.color = text.colorData.default;
};

TextObject.prototype.draw = function(){
  drawText(this.ctx, this.data.text);
};

function ButtonObject(){
  TextObject.call(this);
};
ButtonObject.prototype = new TextObject();
ButtonObject.prototype.constructor = ButtonObject;

ButtonObject.prototype.initialize = function(canvas,ctx,GAME_SETTINGS,data){
  TextObject.prototype.initialize.call(this,canvas,ctx,GAME_SETTINGS,data);
  var rect = this.data.rect;
  rect.x = rect.x?rect.x:(GAME_SETTINGS.WIDTH - rect.width)/2;
  rect.y = rect.y?rect.y:(GAME_SETTINGS.HEIGHT - rect.height)/2;
  rect.color = rect.colorData.default;
};

ButtonObject.prototype.draw = function(){
  drawRect(this.ctx,this.data.rect);
  TextObject.prototype.draw.call(this);
};

//Common Functions
function pointSquareCollusionCheck(x,y,square){
  if(x >= square.x && x <= square.x + square.width && y >= square.y && y <= square.y + square.height )
    return true;
}
function drawRect(ctx, rect){
  if(!rect.color) return;
  ctx.save();
  ctx.beginPath();

  ctx.globalAlpha = rect.globalAlpha?text.globalAlpha:1;
  if(rect.color.fill){
    ctx.fillStyle = rect.color.fill;
    ctx.fillRect(rect.x,rect.y,rect.width,rect.height);
  }
  if(rect.color.stroke){
    ctx.strokeStyle = rect.color.stroke;
    ctx.lineWidth = rect.lineWidth;
    ctx.rect(rect.x,rect.y,rect.width,rect.height);
    ctx.stroke();
  }
  ctx.restore();
}
function drawText(ctx, text){
  if(!text.color) return;
  ctx.save();
  ctx.beginPath();

  ctx.font = text.size+"px "+text.font;
  ctx.textAlign = text.textAlign;
  ctx.textBaseline = text.textBaseline;
  ctx.globalAlpha = text.globalAlpha?text.globalAlpha:1;
  if(text.color.fill){
    ctx.fillStyle = text.color.fill;
    ctx.fillText(text.message, text.x, text.y);
  }
  if(text.color.stroke){
    ctx.strokeStyle = text.color.stroke;
    ctx.lineWidth = text.lineWidth;
    ctx.strokeText(text.message, text.x, text.y);
  }

  ctx.restore();
}
</script>
  </body>
</html>
